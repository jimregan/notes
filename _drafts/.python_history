import json
with open("[download] Downloading video 9 of 23
[youtube] zr3Ofv-1H_4: Downloading webpage
[youtube] zr3Ofv-1H_4: Downloading MPD manifest
[download] Destination: zr3Ofv-1H_4.mp4
with open("H4C320170201SfU8") as jsonfile:
	json.load(jsonfile)
with open("H4C320170201SfU8") as jsonfile:
	api=json.load(jsonfile)
api
api['videodata']
api['videodata']['streams']
api['videodata'][0]['streams']
api['videodata'][0]['streams'][0]
api['videodata'][0]['streams']['files']
api['videodata'][0]['streams']['files'][0]
for video_link in api['videodata'][0]['streams']['files'][0]:
	if video_link['name'] == 'Hög kvalitet':
		url = video_link['url']
for video_link in api['videodata'][0]['streams']['files']:
	if video_link['name'] == 'Hög kvalitet':
		url = video_link['url']
 api['videodata'][0]['streams']['files'][0]
api['videodata'][0]['streams']['files'][0]
api['videodata'][0]['streams']['files'][0]['bandwidth']
api['videodata'][0]['streams']['files'][0]['bandwidth'][0]
for video_link in api['videodata'][0]['streams']['files'][0]['bandwidth']:
	if video_link['name'] == 'Hög kvalitet':
		url = video_link['url']
url
for video_link in api['videodata'][0]['streams']['files'][0]['bandwidth']:
	if video_link['name'] == 'Hög kvalitet':
		url = video_link['downloadurl']
url
len(api['videodata'][0])
len(api['videodata'])
4 == True
5 == 5 > 1
5 == 5 > 2
5 == 5 > 7
(5 == 5) > 7
5 == (5 > 7)
(5 == 5) > 1
5 == (5 > 1)
5 == 4 > 1
from datasets import load_dataset
timit = load_dataset("timit_asr")
from datasets import load_dataset
timit = load_dataset("timit_asr")
timit
timit["train"][0]["audio"]
import ffmpeg
import json
import requests
cc_by = []
other = []
retry = []
seen = []
lic = '"Creative Commons Attribution licence (reuse allowed)"'
def inner(cur_id):
    if cur_id in seen:
        return
    req = requests.get(f"https://www.youtube.com/watch?v={cur_id}")
    if req.status_code != 200:
        retry.append(cur_id)
    if lic in req.text:
        cc_by.append(cur_id)
    else:
        other.append(cur_id)
    seen.append(cur_id)
with open("pl_videos.json") as pl_videos:
    for line in pl_videos.readlines():
        line_data = json.loads(line.strip())
        inner(line_data['id'])
with open("uploads.json") as pl_videos:
    for line in pl_videos.readlines():
        line_data = json.loads(line.strip())
with open("pl_videos.json") as pl_videos:
    for line in pl_videos.readlines():
        line_data = json.loads(line.strip())
        inner(line_data['id'])
with open("uploads.json") as pl_videos:
    for line in pl_videos.readlines():
        line_data = json.loads(line.strip())
        inner(line_data['id'])
with open('proc.json', 'w') as outfile:
    json.dump({'cc-by': cc_by, 'other': other, 'retry': retry}, outfile)
lic = 'Creative Commons Attribution licence (reuse allowed)'
line_data = []
with open("pl_videos.json") as pl_videos:
    for line in pl_videos.readlines():
        line_data = json.loads(line.strip())
        inner(line_data['id'])
line_data
from pathlib import Path
for i in Path(".").glob("*.info.json"):
	print(i)
from pathlib import Path
import json
for i in Path(".").glob("*.info.json"):
	data = json.load(i)
for i in Path(".").glob("*.info.json"):
	data = json.load(str(i))
for i in Path(".").glob("*.info.json"):
	with open(i) as f:
		data = json.load(f)
data
data["license"]
CC_BY = 'Creative Commons Attribution license (reuse allowed)'
for i in Path(".").glob("*.info.json"):
	with open(i) as f:
		data = json.load(f)
		if "license" in data and data["license"] == CC_BY:
			print(i)
cc_by_ids = []
for i in Path(".").glob("*.info.json"):
    with open(i) as f:
        data = json.load(f)
        if "license" in data and data["license"] == CC_BY:
            cc_by_ids.append(i.replace(".info.json", ""))
            cc_by_ids.append(str(i).replace(".info.json", ""))
cc_by_ids = []
for i in Path(".").glob("*.info.json"):
    with open(i) as f:
        data = json.load(f)
        if "license" in data and data["license"] == CC_BY:
            cc_by_ids.append(str(i).replace(".info.json", ""))
cc_by_ids
with open("cc-by-ids.txt", "w") as out:
	for vid in cc_by_ids:
		out.write(vid + "\n")
with open("cc-by-ids.txt", "w") as outf:
	for vid in cc_by_ids:
		outf.write(vid + "\n")
print(len(cc_by_ids))
import datasets
datasets.load_dataset('timit_asr', data_dir='/sbtal/TIMIT/')
import datasets
datasets.load_dataset('timit_asr', data_dir='/sbtal/TIMIT/')
timit = datasets.load_dataset('timit_asr', data_dir='/sbtal/TIMIT/')
timit['train'][0]
timit['train'][0]['phonetic_detail'
timit['train'][0]['phonetic_detail']
from transformers import pipeline
_SWE_MODEL = "KBLab/wav2vec2-large-voxrex-swedish"
file = "/tmp/2442101120000160421_759s.wav"
output = pipe(file, chunk_length_s=10, return_timestamps="word")
pipe = pipeline(model=_SWE_MODEL)
output = pipe(file, chunk_length_s=10, return_timestamps="word")
output
output["chunks"]
output["chunks"][1]["text"]
#output["chunks"][1]["text"] = "så".upper()
"så".upper()
output["chunks"][1]["text"] = "så".upper()
output
output["text"].replace("saag", "så")
for chunk in output["chunks"]:
	print(chunk["timestamp"])
for chunk in output["chunks"]:
	old_ts = chunk["timestamp"]
	chunk["timestamp"] = (old_ts[0] + 759, old_ts[1] + 759)
output
#for chunk in output["chunks
with open("/tmp/2442101120000160421_759s.ctm", "w") as of:
	for chunk in output["chunks"]:
		of.write(f'2442101120000160421 1 {chunk["timestamp"][0]} {chunk["timestamp"][1] - chunk["timestamp"][0]} {chunk["text"].lower()} 1.0\n")
		of.write(f'2442101120000160421 1 {chunk["timestamp"][0]} {chunk["timestamp"][1] - chunk["timestamp"][0]} {chunk["text"].lower()} 1.0\n')
with open("/tmp/2442101120000160421_759s.ctm", "w") as of:
	for chunk in output["chunks"]:
		of.write(f'2442101120000160421 1 {chunk["timestamp"][0]} {chunk["timestamp"][1] - chunk["timestamp"][0]} {chunk["text"].lower()} 1.0\n")
with open("/tmp/2442101120000160421_759s.ctm", "w") as of:
	for chunk in output["chunks"]:
		of.write(f'2442101120000160421 1 {chunk["timestamp"][0]} {chunk["timestamp"][1] - chunk["timestamp"][0]} {chunk["text"].lower()} 1.0\n')
with open("/tmp/2442101120000160421_759s.ctm", "w") as of:
	for chunk in output["chunks"]:
		of.write(f'2442101120000160421 1 {chunk["timestamp"][0] + 0.3} {chunk["timestamp"][1] - chunk["timestamp"][0]} {chunk["text"].lower()} 1.0\n')
input = "En-au-sick_as_a_dog.ogg"
from transformers import pipeline
model = "jonatasgrosman/wav2vec2-large-xlsr-53-english"
pipe = pipeline(model=model)
output = pipe(input, chunk_length_s=10, return_timestamps="word")
output
import json
json.dump(output)
json.dumps(output)
import torchaudio
arr, smaple_rate = ta.load("example.wav")
import torchaudio as ta
arr, smaple_rate = ta.load("example.wav")
arr
smaple_rate
import pynini
from pynini.lib import pynutil
zero = pynini.string_map([("zéro","0")])
zero
from num2words import num2words
with open("/tmp/cardinal-in") as in, open("/tmp/cardinal-out", "w") as out:
with open("/tmp/cardinal-in") as inf, open("/tmp/cardinal-out", "w") as outf:
	for line in inf.readlines():
		num = line.strip()
		words = num2words(int(line), to="cardinal", lang="sv")
		outf.write(f"{words}~{num}\n")
from num2words import num2words
num2words(21, to="cardinal", lang="sv")
num2words(20, to="cardinal", lang="sv")
num2words(30, to="cardinal", lang="sv")
num2words(31, to="cardinal", lang="sv")
num2words(41, to="cardinal", lang="sv")
num2words(51, to="cardinal", lang="sv")
num2words(61, to="cardinal", lang="sv")
num2words(71, to="cardinal", lang="sv")
num2words(81, to="cardinal", lang="sv")
num2words(91, to="cardinal", lang="sv")
num2words(-23, to="cardinal", lang="sv")
num2words(1000000000000, to="cardinal", lang="sv")
num2words(1000000000000000000000000, to="cardinal", lang="sv")
num2words(2000000000000, to="cardinal", lang="sv")
num2words(1000000000000, to="cardinal", lang="sv")
num2words(1000000000, to="cardinal", lang="sv")
num2words(2000000000, to="cardinal", lang="sv")
num2words(1000000, to="cardinal", lang="sv")
num2words(1000, to="cardinal", lang="sv")
from num2words import num2words
num2words(1000, to="cardinal", lang="sv")
num2words(11000, to="cardinal", lang="sv")
num2words(111000, to="cardinal", lang="sv")
num2words(111000000, to="cardinal", lang="sv")
num2words(1000000, to="cardinal", lang="sv")
num2words(1000000000, to="cardinal", lang="sv")
num2words(1000000000000, to="cardinal", lang="sv")
num2words(1000000000000000, to="cardinal", lang="sv")
num2words(2000000000000000, to="cardinal", lang="sv")
num2words(1000000000000000000, to="cardinal", lang="sv")
num2words(1000000000000000000000, to="cardinal", lang="sv")
num2words(1000000000000000000000000, to="cardinal", lang="sv")
from num2words import num2words
num2words(1001, to="cardinal", lang="hu")
num2words(2001, to="cardinal", lang="hu")
num2words(2001001, to="cardinal", lang="hu")
num2words(20001001, to="cardinal", lang="hu")
num2words(1000000000, to="cardinal", lang="hu")
num2words(1000000000, to="ordinal", lang="hu")
num2words(1, to="ordinal", lang="hu")
num2words(11, to="ordinal", lang="hu")
num2words(2, to="ordinal", lang="hu")
num2words(3, to="ordinal", lang="hu")
num2words(13, to="ordinal", lang="hu")
num2words(12, to="ordinal", lang="hu")
num2words(1111111111111, to="cardinal", lang="hu")
num2words(11111111111111, to="cardinal", lang="hu")
num2words(111111111111111, to="cardinal", lang="hu")
num2words(1111, to="cardinal", lang="hu")
num2words(2111, to="cardinal", lang="hu")
num2words(111111, to="cardinal", lang="hu")
num2words(1111111, to="cardinal", lang="hu")
num2words(1111111, to="cardinal", lang="ga")
from num2words import num2words
num2words(111, to="cardinal", lang="hu")
num2words(211, to="cardinal", lang="hu")
num2words(1211, to="cardinal", lang="hu")
from num2words import num2words
num2words(1000, to="cardinal", lang="hu")
num2words(2000000, to="cardinal", lang="hu")
num2words(1000000, to="cardinal", lang="hu")
num2words(1000, to="cardinal", lang="hu")
num2words(100000, to="cardinal", lang="hu")
from num2words import num2words
num2words(2001, to="cardinal", lang="hu")
num2words(1001, to="cardinal", lang="hu")
num2words(1000, to="cardinal", lang="hu")
num2words(2000, to="cardinal", lang="hu")
num2words(3000, to="cardinal", lang="hu")
num2words(200, to="cardinal", lang="hu")
num2words(2000, to="cardinal", lang="hu")
import nemo_text_processing.text_normalization.sv
import nemo_text_processing.text_normalization.sv.taggers.cardinal
a = cardinal.CardinalFst()
a = nemo_text_processing.text_normalization.sv.taggers.cardinal.CardinalFst()
a.fst
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("1", a.fst)
"1" @ a.fst
bb = "1" @ a.fst
bb.string()
bb = "1000000" @ a.fst
bb.string()
bb = "1111111111111" @ a.fst
bb.string()
exp = 'en biljon etthundraelva miljarder etthundraelva miljoner etthundraelvatusen etthundraelva'
nondet = nemo_text_processing.text_normalization.sv.taggers.cardinal.CardinalFst(False)
nondet = nemo_text_processing.text_normalization.sv.taggers.cardinal.CardinalFst(deterministic=False)
import nemo_text_processing.text_normalization.sv.taggers.cardinal
a = nemo_text_processing.text_normalization.sv.taggers.cardinal.CardinalFst()
nondet = nemo_text_processing.text_normalization.sv.taggers.cardinal.CardinalFst(deterministic=False)
rev = nondet.fst.inverse()
rev = nondet.fst.invert()
exp = 'en biljon etthundraelva miljarder etthundraelva miljoner etthundraelvatusen etthundraelva'
aa = exp @ rev
aa
aa.string()
bb = "1000000" @ a.fst
bb
bb.string()
bb = "111111111111" @ a.fst
bb.string()
from nemo_text_processing.text_normalization.normalize import Normalizer
norm = Normalizer(input_case='cased', lang='sv', cache_dir=CACHE_DIR, overwrite_cache=False)
norm = Normalizer(input_case='cased', lang='sv', cache_dir=None, overwrite_cache=False)
norm.normalize("110")
norm.normalize("sr.")
norm = Normalizer(input_case='cased', lang='pp', cache_dir=CACHE_DIR, overwrite_cache=False)
norm = Normalizer(input_case='cased', lang='pp', cache_dir=None, overwrite_cache=False)
from nemo_text_processing.text_normalization.normalize import Normalizer
norm = Normalizer(input_case='cased', lang='pp', cache_dir=None, overwrite_cache=False)
norm = Normalizer(input_case='cased', lang='sv', cache_dir=None, overwrite_cache=False)
from nemo_text_processing.text_normalization.normalize import Normalizer
norm = Normalizer(input_case='cased', lang='sv', cache_dir=None, overwrite_cache=False)
import nemo_text_processing.text_normalization.sv.taggers.ordinal
import nemo_text_processing.text_normalization.sv.taggers.cardinal
card = cardinal.CardinalFst()
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
cfst = CardinalFst(True)
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
ord = OrdinalFst(cardinal=cfst.fst, deterministic=True)
ord = OrdinalFst(cardinal=cfst, deterministic=True)
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
ord = OrdinalFst(cardinal=cfst, deterministic=True)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
card = CardinalFst(True)
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
ord = OrdinalFst(cardinal=card, deterministic=True)
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
ord = OrdinalFst(cardinal=card, deterministic=True)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
card = CardinalFst(True)
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
ord = OrdinalFst(cardinal=card, deterministic=True)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
card = CardinalFst(True)
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
ord = OrdinalFst(cardinal=card, deterministic=True)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
card = CardinalFst(True)
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
ord = OrdinalFst(cardinal=card, deterministic=True)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
card = CardinalFst(True)
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
ord = OrdinalFst(cardinal=card, deterministic=True)
from num2words import num2words
num2words(2000, to="cardinal", lang="sv")
num2words(2000, lang="sv", ordinal=True)
num2words(2001, lang="sv", ordinal=True)
num2words(2000, lang="sv")
num2words(2000000, lang="sv")
num2words(2000000, lang="sv", ordinal=True)
num2words(1000000, lang="sv", ordinal=True)
num2words(2000, lang="sv", ordinal=True)
num2words(2000, lang="sv")
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
import pynini
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
import pynini
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.sv.taggers.date import DateFst
card = CardinalFst(True)
ord = OrdinalFst(cardinal=card, deterministic=True)
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("31", ord.graph)
apply_fst("21", ord.graph)
apply_fst("201", ord.graph)
apply_fst("021", ord.graph)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
import pynini
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
card = CardinalFst(True)
ord = OrdinalFst(cardinal=card, deterministic=True)
apply_fst("31", ord.graph_tens_component)
apply_fst("1", ord.graph_tens_component)
apply_fst("11", ord.graph_tens_component)
apply_fst("30", ord.graph_tens_component)
apply_fst("31", ord.graph_tens_component)
from pynini.lib import pynutil
import pynini
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
card = CardinalFst(True)
ord = OrdinalFst(cardinal=card, deterministic=True)
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("31", ord.graph_tens_component)
apply_fst("31", ord.graph)
apply_fst("131", ord.graph)
apply_fst("031", ord.graph)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
card = CardinalFst(True)
ord = OrdinalFst(cardinal=card, deterministic=True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("31", ord.graph)
apply_fst("1", ord.graph)
apply_fst("131", ord.graph)
apply_fst("131", ord.fstr)
apply_fst("131", ord.fst)
apply_fst("31", ord.fst)
apply_fst("1", ord.fst)
apply_fst("1:a", ord.fst)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.sv.taggers.date import DateFst
card = CardinalFst(True)
ord = OrdinalFst(cardinal=card, deterministic=True)
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("31/12", date.fst)
apply_fst("31/01", date.fst)
apply_fst("31/01/2022", date.fst)
apply_fst("31 januari 2022", date.fst)
apply_fst("2022.12.01", date.fst)
apply_fst("2022-12-01", date.fst)
apply_fst("2022/12/01", date.fst)
apply_fst("2022-12-01", date.fst)
apply_fst("01-01-2023", date.fst)
apply_fst("01/01/2023", date.fst)
apply_fst("01.01.2023", date.fst)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.sv.taggers.date import DateFst
from pynini.lib import pynutil
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
card = CardinalFst(True)
ord = OrdinalFst(cardinal=card, deterministic=True)
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
apply_fst("2022-12-01", date.fst)
apply_fst("2022.12.01", date.fst)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.sv.taggers.date import DateFst
card = CardinalFst(True)
ord = OrdinalFst(cardinal=card, deterministic=True)
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
from pynini.lib import pynutil
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("2022.12.01", date.fst)
apply_fst("2022-12-01", date.fst)
apply_fst("2022/12/01", date.fst)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.sv.taggers.date import DateFst
card = CardinalFst(True)
ord = OrdinalFst(cardinal=card, deterministic=True)
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
import pynini
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.sv.taggers.date import DateFst
card = CardinalFst(True)
ord = OrdinalFst(cardinal=card, deterministic=True)
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.sv.taggers.date import DateFst
card = CardinalFst(True)
ord = OrdinalFst(cardinal=card, deterministic=True)
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.sv.taggers.date import DateFst
card = CardinalFst(True)
ord = OrdinalFst(cardinal=card, deterministic=True)
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("2022/12/01", date.fst)
apply_fst("2022-12-01", date.fst)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
card = CardinalFst(True)
ord = OrdinalFst(cardinal=card, deterministic=True)
from nemo_text_processing.text_normalization.sv.taggers.date import DateFst
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("2022-12-01", date.fst)
apply_fst("2022.12.01", date.fst)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.sv.taggers.date import DateFst
ord = OrdinalFst(cardinal=card, deterministic=True)
card = CardinalFst(True)
ord = OrdinalFst(cardinal=card, deterministic=True)
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("2022.12.01", date.fst)
apply_fst("2022/12/01", date.fst)
apply_fst("2022-12-01", date.fst)
from nemo_text_processing.text_normalization.sv.taggers.date import DateFst
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
apply_fst("2022-12-01", date.fst)
apply_fst("1 jan. 2022", date.fst)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.sv.taggers.date import DateFst
card = CardinalFst(True)
ord = OrdinalFst(cardinal=card, deterministic=True)
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("1 jan. 2022", date.fst)
apply_fst("1 januari 2022", date.fst)
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
apply_fst("1 januari 2022", date.fst)
apply_fst("1 jan. 2022", date.fst)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
import pynini
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.sv.taggers.date import DateFst
card = CardinalFst(True)
ord = OrdinalFst(cardinal=card, deterministic=True)
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("1 jan. 2022", date.fst)
apply_fst("1 feb. 2022", date.fst)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.sv.taggers.date import DateFst
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("1 feb. 2022", date.fst)
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
card = CardinalFst(True)
ord = OrdinalFst(cardinal=card, deterministic=True)
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
from nemo_text_processing.text_normalization.sv.taggers.date import DateFst
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.sv.taggers.date import DateFst
card = CardinalFst(True)
ord = OrdinalFst(cardinal=card, deterministic=True)
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("1 feb. 2022", date.fst)
apply_fst("1:e feb. 2022", date.fst)
apply_fst("1:a feb. 2022", date.fst)
apply_fst("1/ feb. 2022", date.fst)
apply_fst("1. feb. 2022", date.fst)
from nemo_text_processing.text_normalization.sv.taggers.electronic import ElectronicFst
elec = ElectronicFst(deterministic=True)
apply_fst("hund@kth.se", elec.fst)
apply_fst("hund@gmail.com", elec.fst)
apply_fst("http://www.google.com", elec.fst)
apply_fst("www.google.com", elec.fst)
apply_fst("2022-12-01", date.fst)
apply_fst("2022/12/01", date.fst)
apply_fst("1. december 2022", date.fst)
apply_fst("1 december 2022", date.fst)
apply_fst("1:a december 2022", date.fst)
apply_fst("första december 2022", date.fst)
apply_fst("1 dec. 2022", date.fst)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.sv.taggers.date import DateFst
card = CardinalFst(True)
ord = OrdinalFst(cardinal=card, deterministic=True)
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
apply_fst("1 dec. 2022", date.fst)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("1 dec. 2022", date.fst)
apply_fst("första dec. 2022", date.fst)
apply_fst("1:a dec. 2022", date.fst)
fractional_endings = pynini.string_map([
	("ljard", "ljarddel"),
	("tonde", "tondel"),
	("ljon", "ljondel"),
	("lliard", "lliarddel"),
	("llion", "lliondel")
])
ord_words = pynini.project(ord.graph, "output")
pynini.cdrewrite(fractional_endings, "", "EOS", NEMO_SIGMA)
from nemo_text_processing.text_normalization.en.graph_utils import NEMO_SIGMA
pynini.cdrewrite(fractional_endings, "", "EOS", NEMO_SIGMA)
a = pynini.cdrewrite(fractional_endings, "", "EOS", NEMO_SIGMA)
apply_fst("1", a)
apply_fst("1000000", a)
ord.graph @ pynini.cdrewrite(fractional_endings, "", "EOS", NEMO_SIGMA)
a = ord.graph @ pynini.cdrewrite(fractional_endings, "", "EOS", NEMO_SIGMA)
apply_fst("1000000", a)
        fractional_endings = pynini.string_map([
            ("ljarte", "ljarddel"),
            ("tonde", "tondel"),
            ("ljonte", "ljondel"),
            ("lliarte", "lliarddel"),
            ("llionte", "lliondel")
        ])
fractional_endings = pynini.string_map([
    ("ljarte", "ljarddel"),
    ("tonde", "tondel"),
    ("ljonte", "ljondel"),
    ("lliarte", "lliarddel"),
    ("llionte", "lliondel")
])
a = ord.graph @ pynini.cdrewrite(fractional_endings, "", "EOS", NEMO_SIGMA)
apply_fst("1000000", a)
b = pynini.cdrewrite(fractional_endings, "", "EOS", NEMO_SIGMA)
apply_fst("1000000", b)
c = pynini.cdrewrite(fractional_endings, "", "EOS", NEMO_SIGMA) @ ord.graph
apply_fst("1000000", c)
a = ord.graph @ pynini.cdrewrite(fractional_endings, "", "[EOS]", NEMO_SIGMA)
apply_fst("1000000", a)
apply_fst("1000000000", a)
apply_fst("11", a)
apply_fst("15", a)
apply_fst("2", a)
apply_fst("3", a)
fractional_endings = pynini.string_map([
    ("ljarte", "ljarddel"),
    ("tonde", "tondel"),
    ("ljonte", "ljondel"),
    ("lliarte", "lliarddel"),
    ("llionte", "lliondel"),
    ("te", "tedel"),
    ("je", "jedel"),
    ("a", "adel")
])
a = ord.graph @ pynini.cdrewrite(fractional_endings, "", "[EOS]", NEMO_SIGMA)
apply_fst("3", a)
apply_fst("4", a)
apply_fst("5", a)
fractional_endings = pynini.string_map([
    ("ljarte", "ljarddel"),
    ("tonde", "tondel"),
    ("ljonte", "ljondel"),
    ("lliarte", "lliarddel"),
    ("llionte", "lliondel"),
    ("te", "tedel"),
    ("de", "dedel"),
    ("je", "jedel"),
    ("a", "adel")
])
apply_fst("5", a)
apply_fst("2", a)
apply_fst("1", a)
apply_fst("3", a)
apply_fst("4", a)
apply_fst("5", a)
apply_fst("6", a)
apply_fst("7", a)
a = ord.graph @ pynini.cdrewrite(fractional_endings, "", "[EOS]", NEMO_SIGMA)
apply_fst("4", a)
apply_fst("5", a)
apply_fst("50", a)
fractional_endings = pynini.string_map([
    ("ljarte", "ljarddel"),
    ("tionde", "tiondel"),
    ("tonde", "tondel"),
    ("ljonte", "ljondel"),
    ("lliarte", "lliarddel"),
    ("llionte", "lliondel"),
    ("te", "tedel"),
    ("de", "dedel"),
    ("je", "jedel"),
    ("a", "adel")
])
a = ord.graph @ pynini.cdrewrite(fractional_endings, "", "[EOS]", NEMO_SIGMA)
apply_fst("50", a)
apply_fst("15", a)
apply_fst("51", a)
apply_fst("1000000", a)
apply_fst("1000000000", a)
apply_fst("1000", a)
fractional_endings = pynini.string_map([
    ("ljarte", "ljarddel"),
    ("tionde", "tiondel"),
    ("tonde", "tondel"),
    ("ljonte", "ljondel"),
    ("lliarte", "lliarddel"),
    ("llionte", "lliondel"),
    ("tusende", "tusendedel"),
    ("te", "tedel"),
    ("de", "dedel"),
    ("je", "jedel"),
    ("dra", "dradel")
    ("a", "adel")
])
fractional_endings = pynini.string_map([
    ("ljarte", "ljarddel"),
    ("tionde", "tiondel"),
    ("tonde", "tondel"),
    ("ljonte", "ljondel"),
    ("lliarte", "lliarddel"),
    ("llionte", "lliondel"),
    ("tusende", "tusendedel"),
    ("te", "tedel"),
    ("de", "dedel"),
    ("je", "jedel"),
    ("dra", "dradel"),
    ("a", "adel")
])
a = ord.graph @ pynini.cdrewrite(fractional_endings, "", "[EOS]", NEMO_SIGMA)
apply_fst("1000", a)
apply_fst("100", a)
fractional_endings = pynini.string_map([
    ("ljarte", "ljarddel"),
    ("tionde", "tiondel"),
    ("tonde", "tondel"),
    ("ljonte", "ljondel"),
    ("lliarte", "lliarddel"),
    ("llionte", "lliondel"),
    ("tusende", "tusendel"),
    ("te", "tedel"),
    ("de", "dedel"),
    ("je", "jedel"),
    ("drade", "dradel"),
    ("a", "adel")
])
a = ord.graph @ pynini.cdrewrite(fractional_endings, "", "[EOS]", NEMO_SIGMA)
apply_fst("100", a)
apply_fst("1000", a)
apply_fst("2000", a)
apply_fst("2001", a)
from nemo_text_processing.text_normalization.sv.taggers.fraction import FractionFst
frac = FractionFst(cardinal=card, ordinal=ord, deterministic=True)
from nemo_text_processing.text_normalization.sv.taggers.fraction import FractionFst
frac = FractionFst(cardinal=card, ordinal=ord, deterministic=True)
from nemo_text_processing.text_normalization.sv.taggers.fraction import FractionFst
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
card = CardinalFst(True)
ord = OrdinalFst(cardinal=card, deterministic=True)
frac = FractionFst(cardinal=card, ordinal=ord, deterministic=True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("1 2/3", frac.fst)
apply_fst("1 1/3", frac.fst)
apply_fst("1 1/2", frac.fst)
apply_fst("1 1/4", frac.fst)
apply_fst("1 1/21", frac.fst)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.sv.taggers.fraction import FractionFst
card = CardinalFst(True)
ord = OrdinalFst(cardinal=card, deterministic=True)
frac = FractionFst(cardinal=card, ordinal=ord, deterministic=True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("1 1/21", frac.fst)
apply_fst("1 1/2", frac.fst)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.sv.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.sv.taggers.fraction import FractionFst
card = CardinalFst(True)
ord = OrdinalFst(cardinal=card, deterministic=True)
frac = FractionFst(cardinal=card, ordinal=ord, deterministic=True)
from nemo_text_processing.text_normalization.sv.taggers.fraction import FractionFst
frac = FractionFst(cardinal=card, ordinal=ord, deterministic=True)
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
from pynini.lib import pynutil
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("21", card.two_digit_non_zero)
apply_fst("21", card.tens)
apply_fst("11", card.tens)
apply_fst("1", card.tens)
apply_fst("10", card.tens)
apply_fst("20", card.tens)
apply_fst("30", card.tens)
apply_fst("30", card.two_digit_non_zero)
apply_fst("12", card.two_digit_non_zero)
apply_fst("11", card.two_digit_non_zero)
apply_fst("01", card.two_digit_non_zero)
apply_fst("11", card.two_digit_non_zero)
from pynini.lib import pynutil
import pynini
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
import pynini
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("11", card.two_digit_non_zero)
apply_fst("99", card.two_digit_non_zero)
apply_fst("90", card.two_digit_non_zero)
apply_fst("28", card.two_digit_non_zero)
apply_fst("2", card.two_digit_non_zero)
apply_fst("8", card.two_digit_non_zero)
from pynini.lib import pynutil
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("90", card.two_digit_non_zero)
card = CardinalFst(deterministic = True)
apply_fst("90", card.two_digit_non_zero)
apply_fst("99", card.two_digit_non_zero)
apply_fst("28", card.two_digit_non_zero)
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
card = CardinalFst(deterministic = True)
apply_fst("28", card.two_digit_non_zero)
apply_fst("20", card.two_digit_non_zero)
apply_fst("10", card.tens)
apply_fst("11", card.tens)
apply_fst("13", card.tens)
apply_fst("19", card.tens)
apply_fst("19", card.two_digit_non_zero)
apply_fst("99", card.two_digit_non_zero)
apply_fst("01", card.two_digit_non_zero)
apply_fst("1", card.two_digit_non_zero)
apply_fst("1", card.hundreds)
apply_fst("101", card.hundreds)
apply_fst("100", card.hundreds)
apply_fst("199", card.hundreds)
apply_fst("999", card.hundreds)
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("999", card.hundreds)
apply_fst("999", card.two_digit_non_zero)
apply_fst("99", card.two_digit_non_zero)
import pynini
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("999", card.two_digit_non_zero)
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("999", card.two_digit_non_zero)
card = CardinalFst(deterministic = True)
apply_fst("999", card.two_digit_non_zero)
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
card = CardinalFst(deterministic = True)
apply_fst("999", card.two_digit_non_zero)
apply_fst("999", card.hundreds)
apply_fst("1", card.hundreds)
apply_fst("111", card.hundreds)
apply_fst("011", card.hundreds)
apply_fst("1011", card.hundreds)
apply_fst("111", card.hundreds)
apply_fst("11", card.hundreds)
apply_fst("1", card.hundreds)
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
import pynini
card = CardinalFst(deterministic = True)
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("111", card.hundreds)
apply_fst("999", card.hundreds)
apply_fst("900", card.hundreds)
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
card = CardinalFst(deterministic = True)
apply_fst("900", card.hundreds)
apply_fst("999", card.hundreds)
apply_fst("99", card.hundreds)
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_graph("2000", card.fst)
apply_fst("2000", card.fst)
rev = card.fst.
apply_fst("triljárddatriljovnnabiljárddabiljovnnamiljárddaguoktemiljovnna", rev)
apply_graph("2000", card.fst)
apply_fst("2000", card.fst)
apply_fst("2001", card.fst)
apply_fst("1", card.fst)
apply_fst("0", card.fst)
apply_graph("2000000000000000", card.fst)
apply_fst("2000000000000000", card.fst)
card = CardinalFst(deterministic = True)
apply_fst("2000000000000000", card.fst)
apply_fst("200000000", card.fst)
apply_fst("2", card.fst)
card = CardinalFst(deterministic = True)
import pynini
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
def apply_fst(text, fst):
apply_fst("2", card.fst)
apply_fst("12", card.fst)
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("12", card.fst)
card = CardinalFst(deterministic = True)
apply_fst("12", card.fst)
apply_fst("2", card.fst)
apply_fst("1", card.fst)
apply_fst("11", card.fst)
apply_fst("111", card.fst)
apply_fst("0", card.fst)
apply_fst("1", card.fst)
apply_fst("1000", card.fst)
apply_fst("10000", card.fst)
apply_fst("1000000", card.fst)
apply_fst("10000000", card.fst)
apply_fst("0010000000", card.fst)
apply_fst("01", card.fst)
apply_fst("0000000000001", card.fst)
apply_fst("11111111111111111"", card.fst)
apply_fst("11111111111111111", card.fst)
apply_fst("1111111111111", card.fst)
apply_fst("1000", card.fst)
apply_fst("100", card.fst)
import pynini
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("100", card.fst)
apply_fst("1000", card.fst)
apply_fst("0001000", card.fst)
import pynini
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
from pynini.lib import pynutil
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("0001000", card.fst)
apply_fst("0001000", card.graph_thousands_component_at_least_one_non_zero_digit)
apply_fst("1000", card.graph_thousands_component_at_least_one_non_zero_digit)
apply_fst("2000", card.graph_thousands_component_at_least_one_non_zero_digit)
apply_fst("001000", card.graph_thousands_component_at_least_one_non_zero_digit)
apply_fst("001111", card.graph_thousands_component_at_least_one_non_zero_digit)
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("001111", card.graph_thousands_component_at_least_one_non_zero_digit)
card = CardinalFst(deterministic = True)
apply_fst("001111", card.graph_thousands_component_at_least_one_non_zero_digit)
apply_fst("001000", card.graph_thousands_component_at_least_one_non_zero_digit)
apply_fst("001000", card.fst)
apply_fst("1000", card.fst)
apply_fst("1", card.fst)
apply_fst("2", card.fst)
apply_fst("-1000", card.fst)
rev = card.fst.invert()
apply_fst("duhat", rev)
rev = pynini.invert(card.fst)
apply_fst("duhat", rev)
rev
apply_fst("100", rev)
apply_fst("duhat", card.fst)
rev = pynini.invert(card.graph)
apply_fst("100", rev)
apply_fst("1", rev)
apply_fst("10000000000000000", rev)
apply_fst(duhat", rev)
apply_fst("duhat", rev)
apply_fst("vihttaduhátguoktẹčuođigolbma", rev)
apply_fst("vihttaduhátguoktečuođigolbma", rev)
apply_fst("ovcciduhátokta", rev)
apply_fst("duhat", rev)
apply_fst("golbma", rev)
apply_fst("vihtta", rev)
apply_fst("vihttaduhát", rev)
apply_fst("duhát", rev)
import pynini
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
rev = pynini.invert(card.graph)
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("duhát", rev)
apply_fst("vihttaduhát", rev)
apply_fst("ovcciduhátokta", rev)
apply_fst("vihttaduhátguoktečuođigolbma", rev)
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
ncard = CardinalFst(deterministic = False)
rev = pynini.invert(ncard.graph)
thing = "logimiljárddaovccičuođigávccilogičiežamiljovnnaguhttačuođivihttaloginjealljẹduhátgolbmačuođiguoktẹlogiokta"
apply_fst(thing, rev)
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
thing = "logimiljárddaovccičuođigávccilogičiežamiljovnnaguhttačuođivihttaloginjealljẹduhátgolbmačuođiguoktẹlogiokta"
apply_fst(thing, rev)
ncard = CardinalFst(deterministic = False)
rev = pynini.invert(ncard.graph)
apply_fst(thing, rev)
apply_fst(thing, rev @ pynini.cdrewrite(pynini.cross("ẹ", "e"), "", "", NEMO_SIGMA))
from nemo_text_processing.text_normalization.en.graph_utils import NEMO_SIGMA
apply_fst(thing, rev @ pynini.cdrewrite(pynini.cross("ẹ", "e"), "", "", NEMO_SIGMA))
apply_fst("logimiljárdda", rev )
apply_fst("logimiljárddaovcci", rev )
apply_fst("logimiljárddaovccičuođ", rev )
apply_fst("logimiljárddaovccičuođi", rev )
apply_fst("čuođigávcci", rev )
apply_fst("logimiljárddaovccičuođigávccilogi", rev )
apply_fst("čuođigávccilogi", rev )
apply_fst("čieža", rev )
thing
apply_fst( "logimiljárddaovccičuođigávccilogičiežamiljovnna", rev )
apply_fst( "logimiljárddaovccičuođigávccilogičieža", rev )
apply_fst( "logimiljárddaovccičuođigávccilogi", rev )
apply_fst( "logimiljárddaovccičuođigávcci", rev )
apply_fst( "logimiljárddaovccičuođi", rev )
apply_fst( "logimiljárddaovcc", rev )
apply_fst( "logimiljárddaovcci", rev )
apply_fst( "čuođičieža", rev )
apply_fst( "10 987 654 321", card.fst )
apply_fst( "10 987 654 321", ncard.fst )
card = CardinalFst(deterministic = True)
apply_fst( "10 987 654 321", card.fst )
apply_fst( "117 401 067", card.fst )
apply_fst( "456", card.fst )
apply_fst( "401 067", card.fst )
apply_fst( "401 000", card.fst )
apply_fst( "9 000", card.fst )
from nemo_text_processing.text_normalization.en.graph_utils import NEMO_SIGMA
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst( "9 000", card.fst )
card = CardinalFst(deterministic = True)
apply_fst( "9 000", card.fst )
apply_fst( "9000", card.fst )
apply_fst( "9001", card.fst )
apply_fst( "1001", card.fst )
apply_fst( "1000", card.fst )
apply_fst( "2000", card.fst )
apply_fst( "2000000", card.fst )
apply_fst( "2000001", card.fst )
apply_fst( "2 000 001", card.fst )
apply_fst( "2 000 000", card.fst )
apply_fst( "2 000 000 000", card.fst )
apply_fst( "2 000", card.fst )
apply_fst( "2000", card.fst )
apply_fst( "12000", card.fst )
apply_fst( "12001", card.fst )
from pynini.lib import pynutil
graph_million = pynutil.add_weight(pynini.cross("000001", "un millón"), -0.001)
import pynini
graph_million = pynutil.add_weight(pynini.cross("000001", "un millón"), -0.001)
graph_million |= graph_thousands_component_at_least_one_none_zero_digit_no_one + pynutil.insert(" millones")
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("1000", card.fst)
apply_fst("1", card.fst)
apply_fst("1 000", card.fst)
apply_fst("200", card.hundreds)
apply_fst("201", card.hundreds)
apply_fst("211", card.hundreds)
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
card = CardinalFst(deterministic = True)
apply_fst("211", card.hundreds)
apply_fst("211", card.graph_thousands_component_at_least_one_none_zero_digit_no_one)
apply_fst("1000", card.graph_thousands_component_at_least_one_none_zero_digit_no_one)
from num2words import num2words
num2words(10000, lang="hu")
num2words(5000, lang="hu")
num2words(5006, lang="hu")
f = open("/home/joregan/NeMo/tests/nemo_text_processing/es/data_text_normalization/test_cases_cardinal.txt")
of = open("/tmp/hu-out", "w")
for line in f.readlines():
	p = line.split("~")
	num = num2words(str(p[0].replace(" ", "").replace(".", "")), lang="hu")
	of.write(f"{p[0]}~{num}\n")
f = open("/home/joregan/NeMo/tests/nemo_text_processing/es/data_text_normalization/test_cases_cardinal.txt")
	of.write(f"{p[0]}~{num}\n")
of = open("/tmp/hu-out", "w")
for line in f.readlines():
	p = line.split("~")
	num = num2words(str(p[0].replace(" ", "").replace(".", "")), lang="hu")
	of.write(f"{p[0]}~{num}\n")
	print(f"{p[0]}~{num}\n")
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.hu.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.hu.taggers.ordinal import OrdinalFst
card = CardinalFst(deterministic = True)
ord = OrdinalFst(cardinal=card, deterministic=True)
from nemo_text_processing.text_normalization.hu.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
ord = OrdinalFst(cardinal=card, deterministic=True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("1.", ord.graph)
apply_fst("1.", ord.fst)
apply_fst("11.", ord.fst)
apply_fst("12.", ord.fst)
apply_fst("212.", ord.fst)
apply_fst("0.", ord.fst)
apply_fst("2.", ord.fst)
apply_fst("1100.", ord.fst)
apply_fst("ezerszázadik", ord.fst)
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.hu.taggers.ordinal import OrdinalFst
card = CardinalFst(deterministic = True)
ord = OrdinalFst(cardinal=card, deterministic=True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("ezerszázadik", ord.fst)
apply_fst("11.", ord.fst)
from pynini.lib import pynutil
from nemo_text_processing.text_normalization.hu.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.hu.taggers.fraction import FractionFst
card = CardinalFst(deterministic = True)
ord = OrdinalFst(cardinal=card, deterministic=True)
frac = FractionFst(card, ord, deterministic=True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("11", frac.fst)
apply_fst("1", frac.fst)
apply_fst("1", frac.fractional)
apply_fst("100", frac.fractional)
frac
frac.fractional
apply_fst("3", frac.fractional)
apply_fst("2", frac.fractional)
from nemo_text_processing.text_normalization.hu.taggers.fraction import FractionFst
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.hu.taggers.ordinal import OrdinalFst
card = CardinalFst(deterministic = True)
ord = OrdinalFst(cardinal=card, deterministic=True)
frac = FractionFst(card, ord, deterministic=True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("2", frac.fractional)
apply_fst("2.", frac.fractional)
apply_fst("2/", frac.numerator)
apply_fst("2", frac.denominator)
og = ord.bare_ordinals
"2" @ og
("2" @ og).string()
("2" @ og)
two = "2" @ og
two.string()
two.write_to_string()
two = "3" @ og
two.write_to_string()
apply_fst("2", ord.bare_ordinals)
apply_fst("2", ord.fst)
apply_fst("2.", ord.fst)
apply_fst("2.", ord.bare_ordinals)
apply_fst("2", ord.bare_ordinals)
apply_fst("2.", ord.graph)
apply_fst("2", ord.bare_ordinals)
apply_fst("02", ord.bare_ordinals)
apply_fst("200", ord.bare_ordinals)
from nemo_text_processing.text_normalization.hu.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.hu.taggers.fraction import FractionFst
card = CardinalFst(deterministic = True)
ord = OrdinalFst(cardinal=card, deterministic=True)
frac = FractionFst(card, ord, deterministic=True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("200", ord.bare_ordinals)
apply_fst("200", frac.graph)
apply_fst("200", frac.fractional)
apply_fst("2", frac.fractional)
apply_fst("1", frac.fractional)
apply_fst("1", ord.bare_ordinals)
from nemo_text_processing.text_normalization.en.graph_utils import NEMO_SIGMA
thing = pynini.string_map([("1", "ones")])
foo = thing @ pynini.cdrewrite(pynutil.delete("s"), "", "[EOS]", NEMO_SIGMA)
apply_fst("1", thing)
apply_fst("1", foo)
apply_fst("1", card.graph)
apply_fst("100", card.graph)
apply_fst("10000", card.graph)
apply_fst("100000", card.graph)
apply_fst("1000000", card.graph)
apply_fst("1000001", card.graph)
apply_fst("1000000000", card.graph)
apply_fst("1000000001", card.graph)
apply_fst("1001", card.graph)
apply_fst("1000", card.graph)
apply_fst("1000", ord.graph)
apply_fst("1000.", ord.graph)
apply_fst("1000000.", ord.graph)
apply_fst("1000001.", ord.graph)
apply_fst("100001.", ord.graph)
apply_fst("1111111.", ord.graph)
apply_fst("111111.", ord.graph)
apply_fst("1000000.", ord.graph)
apply_fst("2000000.", ord.graph)
apply_fst("12000000.", ord.graph)
delete_extra_hyphens = pynini.cross(pynini.closure("-", 1), "-")
delete_hyphen = pynutil.delete(pynini.closure("-"))
"foo----"@ pynini.cdrewrite(delete_hyphen, "", "[EOS]", NEMO_SIGMA)
("foo----"@ pynini.cdrewrite(delete_hyphen, "", "[EOS]", NEMO_SIGMA)).string()
from nemo_text_processing.text_normalization.en.graph_utils import NEMO_SIGMA
from nemo_text_processing.text_normalization.hu.taggers.fraction import FractionFst
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.hu.taggers.ordinal import OrdinalFst
card = CardinalFst(deterministic = True)
ord = OrdinalFst(cardinal=card, deterministic=True)
frac = FractionFst(card, ord, deterministic=True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("12000000.", ord.graph)
apply_fst("12000000.", card.graph)
apply_fst("12000000", card.graph)
apply_fst("12000001", card.graph)
apply_fst("1.", ord.graph)
apply_fst("1.", ord.bare_ordinals)
apply_fst("1", ord.bare_ordinals)
apply_fst("1", card.graph)
apply_fst("1", ord.bare_ordinals)
apply_fst("01", ord.bare_ordinals)
apply_fst("000000000000000000000001", ord.bare_ordinals)
len('000000000000000000000001')
from nemo_text_processing.text_normalization.en.graph_utils import NEMO_DIGIT
NEMO_DIGIT ** 24
from nemo_text_processing.text_normalization.hu.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("1000", card.graph)
apply_fst("10000", card.graph)
apply_fst("100000", card.graph)
apply_fst("1000000", card.graph)
card.graph.start()
from pynini import NO_STATE_ID
ord = OrdinalFst(cardinal=card, deterministic=True)
ord.bare_ordinals.start()
ord.bare_ordinals.start() == NO_STATE_ID
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("1000000", card.graph)
ord = OrdinalFst(cardinal=card, deterministic=True)
from nemo_text_processing.text_normalization.hu.taggers.ordinal import OrdinalFst
ord = OrdinalFst(cardinal=card, deterministic=True)
apply_fst("1000000", ord.graph)
apply_fst("1000000.", ord.graph)
apply_fst("1000000.", ord.bare_ordinals)
apply_fst("1000000", ord.bare_ordinals)
apply_fst("1", ord.bare_ordinals)
apply_fst("11", ord.bare_ordinals)
apply_fst("111", ord.bare_ordinals)
apply_fst("111111", ord.bare_ordinals)
apply_fst("111111111111", ord.bare_ordinals)
apply_fst("000000000000000000000000111111111111", ord.bare_ordinals)
apply_fst("000000000000000000000000111111111111", card.graph)
apply_fst("111111111111", card.graph)
endings = pynini.string_file("/home/joregan/NeMo-text-processing/nemo_text_processing/text_normalization/hu/data/ordinals/endings.tsv")
endings
apply_fst("hat", endings)
exceptions = pynini.string_file("/home/joregan/NeMo-text-processing/nemo_text_processing/text_normalization/hu/data/ordinals/exceptional.tsv")
apply_fst("egy", exceptions)
bare = card.graph @ pynini.cdrewrite(exceptions, "[BOS]", "[EOS]", NEMO_SIGMA) @ pynini.cdrewrite(endings, "", "[EOS]", NEMO_SIGMA)
from nemo_text_processing.text_normalization.en.graph_utils import NEMO_SIGMA
bare = card.graph @ pynini.cdrewrite(exceptions, "[BOS]", "[EOS]", NEMO_SIGMA) @ pynini.cdrewrite(endings, "", "[EOS]", NEMO_SIGMA)
apply_fst("1", bare)
apply_fst("12", bare)
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.hu.taggers.ordinal import OrdinalFst
card = CardinalFst(deterministic = True)
ord = OrdinalFst(cardinal=card, deterministic=True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("111111111111", ord.bare_ordinals)
apply_fst("11", ord.bare_ordinals)
bare = card.graph @ pynini.cdrewrite(exceptions, "[BOS]", "[EOS]", NEMO_SIGMA) @ pynini.cdrewrite(endings, "", "[EOS]", NEMO_SIGMA)
endings = pynini.string_file("/home/joregan/NeMo-text-processing/nemo_text_processing/text_normalization/hu/data/ordinals/endings.tsv")
exceptions = pynini.string_file("/home/joregan/NeMo-text-processing/nemo_text_processing/text_normalization/hu/data/ordinals/exceptional.tsv")
from nemo_text_processing.text_normalization.en.graph_utils import NEMO_SIGMA
bare = card.graph @ pynini.cdrewrite(exceptions, "[BOS]", "[EOS]", NEMO_SIGMA) @ pynini.cdrewrite(endings, "", "[EOS]", NEMO_SIGMA)
apply_fst("11", bare)
apply_fst("11", bare.optimize())
thing =  pynini.cdrewrite(exceptions, "[BOS]", "[EOS]", NEMO_SIGMA) @ pynini.cdrewrite(endings, "", "[EOS]", NEMO_SIGMA)
bare2 = card.graph @ thing
apply_fst("11", bare2)
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.hu.taggers.ordinal import OrdinalFst
card = CardinalFst(deterministic = True)
ord = OrdinalFst(cardinal=card, deterministic=True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("11", ord.bare_ordinals)
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.hu.taggers.ordinal import OrdinalFst
card = CardinalFst(deterministic = True)
ord = OrdinalFst(cardinal=card, deterministic=True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("11", ord.graph_bare_ordinals)
ordinal = OrdinalFst(cardinal=card, deterministic=True)
from nemo_text_processing.text_normalization.hu.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
ordinal = OrdinalFst(cardinal=card, deterministic=True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("11", ordinal.graph_bare_ordinals)
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.hu.taggers.ordinal import OrdinalFst
card = CardinalFst(deterministic = True)
ord = OrdinalFst(cardinal=card, deterministic=True)
from nemo_text_processing.text_normalization.hu.taggers.fraction import FractionFst
frac = FractionFst(card, ord, deterministic=True)
from nemo_text_processing.text_normalization.hu.taggers.fraction import FractionFst
from nemo_text_processing.text_normalization.hu.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
card = CardinalFst(deterministic = True)
ord = OrdinalFst(cardinal=card, deterministic=True)
frac = FractionFst(card, ord, deterministic=True)
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.hu.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.hu.taggers.fraction import FractionFst
card = CardinalFst(deterministic = True)
ord = OrdinalFst(cardinal=card, deterministic=True)
frac = FractionFst(card, ord, deterministic=True)
import pynini
from pynini.lib import pynutil
def apply_fst(text, fst):
  """ Given a string input, returns the output string
  produced by traversing the path with lowest weight.
  If no valid path accepts input string, returns an
  error.
  """
  try:
     print(pynini.shortestpath(text @ fst).string())
  except pynini.FstOpError:
    print(f"Error: No valid output with given input: '{text}'")
apply_fst("11", frac.fractional)
apply_fst("1", frac.fractional)
apply_fst("1 1/1", frac.fst)
apply_fst("1 1/2", frac.fst)
apply_fst("1 1/12", frac.fst)
singular = {
    "er": "t nek rel ért ré ig ként ben en nél be re hez ből ről től",
    "ek": "et nek kel ért ké ig ként ben en nél be re hez ből ről től",
    "amm": "ot nak al ért á ig ként ban on nál ba ra hoz ból ról tól",
    "ok": "at nak kal ért ká ig ként ban on nál ba ra hoz ból ról tól",
    "alék": "ot nak kal ért ká ig ként ban on nál ba ra hoz ból ról tól",
    "erc": "et nek cel ért cé ig ként ben en nél be re hez ből ről től",
}
keys_sorted = sorted(singular, key=lambda k: len(singular[k]), reverse=False)
keys_sorted
keys_sorted = sorted(singular, key=lambda k: len(singular[k]), reverse=False)
keys_sorted
keys_sorted = sorted(singular, key=lambda k: len(k), reverse=False)
keys_sorted
keys_sorted = sorted(singular, key=lambda k: len(k), reverse=True)
keys_sorted
def naive_inflector(abbr: str, word: str):
    singular = {
        "er": "t nek rel ért ré ig ként ben en nél be re hez ből ről től",
        "ek": "et nek kel ért ké ig ként ben en nél be re hez ből ről től",
        "amm": "ot nak al ért á ig ként ban on nál ba ra hoz ból ról tól",
        "ok": "at nak kal ért ká ig ként ban on nál ba ra hoz ból ról tól",
        "alék": "ot nak kal ért ká ig ként ban on nál ba ra hoz ból ról tól",
        "erc": "et nek cel ért cé ig ként ben en nél be re hez ből ről től",
    }
    keys_sorted = sorted(singular, key=lambda k: len(k), reverse=True)
    plural = {
        "er": "ek",
        "erc": "ek",
        "amm": "ok",
        "alék": "ok"
    }
    def get_key():
        for key in keys_sorted:
            if word.endswith(key):
                return key
        return None
    forms = []
    key = get_key()
    for form in singular[key].split():
        forms.append((f"{abbr}-{form}", f"{word}{form}"))
    plural_form = plural[key]
    forms.append((f"{abbr}-{plural_form}", f"{word}{plural_form}"))
    for form in singular[plural_form].split():
        forms.append((f"{abbr}-{plural_form}{form}", f"{word}{plural_form}{form}"))
    return forms
naive_inflector("szept.", "szeptember")
def naive_inflector(abbr: str, word: str):
    singular = {
        "er": "t nek rel ért ré ig ként ben en nél be re hez ből ről től",
        "ek": "et nek kel ért ké ig ként ben en nél be re hez ből ről től",
        "amm": "ot nak al ért á ig ként ban on nál ba ra hoz ból ról tól",
        "um": "ot nak mal ért má ig ként ban on nál ba ra hoz ból ról tól",
        "ok": "at nak kal ért ká ig ként ban on nál ba ra hoz ból ról tól",
        "ák": "at nak kal ért ká ig ként ban on nál ba ra hoz ból ról tól",
        "alék": "ot nak kal ért ká ig ként ban on nál ba ra hoz ból ról tól",
        "erc": "et nek cel ért cé ig ként ben en nél be re hez ből ről től",
        "óra": "át ának ával áért ává áig aként ában án ánál ába ára ához ából áról ától akor",
    }
    keys_sorted = sorted(singular, key=lambda k: len(k), reverse=True)
    plural = {
        "er": "ek",
        "erc": "ek",
        "amm": "ok",
        "um": "ok",
        "alék": "ok"
    }
    def get_key():
        if word == "óra":
            return "óra"
        for key in keys_sorted:
            if word.endswith(key):
                return key
        return None
    forms = []
    key = get_key()
    outword = word
    if outword[-1] in ["a", "e"]:
        outword = outword[:-1]
    for form in singular[key].split():
        forms.append((f"{abbr}-{form}", f"{outword}{form}"))
    plural_form = plural[key]
    forms.append((f"{abbr}-{plural_form}", f"{outword}{plural_form}"))
    for form in singular[plural_form].split():
        forms.append((f"{abbr}-{plural_form}{form}", f"{outword}{plural_form}{form}"))
    return forms
naive_inflector("o.", "óra")
def naive_inflector(abbr: str, word: str):
    singular = {
        "er": "t nek rel ért ré ig ként ben en nél be re hez ből ről től",
        "ek": "et nek kel ért ké ig ként ben en nél be re hez ből ről től",
        "amm": "ot nak al ért á ig ként ban on nál ba ra hoz ból ról tól",
        "um": "ot nak mal ért má ig ként ban on nál ba ra hoz ból ról tól",
        "ok": "at nak kal ért ká ig ként ban on nál ba ra hoz ból ról tól",
        "ák": "at nak kal ért ká ig ként ban on nál ba ra hoz ból ról tól",
        "alék": "ot nak kal ért ká ig ként ban on nál ba ra hoz ból ról tól",
        "erc": "et nek cel ért cé ig ként ben en nél be re hez ből ről től",
        "óra": "át ának ával áért ává áig aként ában án ánál ába ára ához ából áról ától akor",
    }
    keys_sorted = sorted(singular, key=lambda k: len(k), reverse=True)
    plural = {
        "er": "ek",
        "erc": "ek",
        "amm": "ok",
        "um": "ok",
        "alék": "ok",
        "óra": "ák",
    }
    def get_key():
        if word == "óra":
            return "óra"
        for key in keys_sorted:
            if word.endswith(key):
                return key
        return None
    forms = []
    key = get_key()
    outword = word
    if outword[-1] in ["a", "e"]:
        outword = outword[:-1]
    for form in singular[key].split():
        forms.append((f"{abbr}-{form}", f"{outword}{form}"))
    plural_form = plural[key]
    forms.append((f"{abbr}-{plural_form}", f"{outword}{plural_form}"))
    for form in singular[plural_form].split():
        forms.append((f"{abbr}-{plural_form}{form}", f"{outword}{plural_form}{form}"))
    return forms
naive_inflector("o.", "óra")
def naive_inflector(abbr: str, word: str):
    singular = {
        "er": "t nek rel ért ré ig ként ben en nél be re hez ből ről től",
        "ek": "et nek kel ért ké ig ként ben en nél be re hez ből ről től",
        "amm": "ot nak al ért á ig ként ban on nál ba ra hoz ból ról tól",
        "um": "ot nak mal ért má ig ként ban on nál ba ra hoz ból ról tól",
        "ok": "at nak kal ért ká ig ként ban on nál ba ra hoz ból ról tól",
        "ák": "at nak kal ért ká ig ként ban on nál ba ra hoz ból ról tól",
        "alék": "ot nak kal ért ká ig ként ban on nál ba ra hoz ból ról tól",
        "erc": "et nek cel ért cé ig ként ben en nél be re hez ből ről től",
        "óra": "át ának ával áért ává áig aként ában án ánál ába ára ához ából áról ától akor",
    }
    keys_sorted = sorted(singular, key=lambda k: len(k), reverse=True)
    plural = {
        "er": "ek",
        "erc": "ek",
        "amm": "ok",
        "um": "ok",
        "alék": "ok",
        "óra": "ák",
    }
    def get_key():
        if word == "óra":
            return "óra"
        for key in keys_sorted:
            if word.endswith(key):
                return key
        return None
    forms = []
    key = get_key()
    outword = word
    if outword[-1] in ["a", "e"]:
        outword = outword[:-1]
    def tweak(form: str) -> str:
        if outword == word:
            return form
        assert form[0] in ["a", "e", "á", "é"]
        return form[1:]
    for form in singular[key].split():
        forms.append((f"{abbr}-{tweak(form)}", f"{outword}{form}"))
    plural_form = plural[key]
    forms.append((f"{abbr}-{tweak(plural_form)}", f"{outword}{plural_form}"))
    for form in singular[plural_form].split():
        forms.append((f"{abbr}-{tweak(plural_form)}{form}", f"{outword}{plural_form}{form}"))
    return forms
def naive_inflector(abbr: str, word: str):
    singular = {
        "er": "t nek rel ért ré ig ként ben en nél be re hez ből ről től",
        "ek": "et nek kel ért ké ig ként ben en nél be re hez ből ről től",
        "amm": "ot nak al ért á ig ként ban on nál ba ra hoz ból ról tól",
        "um": "ot nak mal ért má ig ként ban on nál ba ra hoz ból ról tól",
        "ok": "at nak kal ért ká ig ként ban on nál ba ra hoz ból ról tól",
        "ák": "at nak kal ért ká ig ként ban on nál ba ra hoz ból ról tól",
        "alék": "ot nak kal ért ká ig ként ban on nál ba ra hoz ból ról tól",
        "erc": "et nek cel ért cé ig ként ben en nél be re hez ből ről től",
        "óra": "át ának ával áért ává áig aként ában án ánál ába ára ához ából áról ától akor",
    }
    keys_sorted = sorted(singular, key=lambda k: len(k), reverse=True)
    plural = {
        "er": "ek",
        "erc": "ek",
        "amm": "ok",
        "um": "ok",
        "alék": "ok",
        "óra": "ák",
    }
    def get_key():
        if word == "óra":
            return "óra"
        for key in keys_sorted:
            if word.endswith(key):
                return key
        return None
    forms = []
    key = get_key()
    outword = word
    if outword[-1] in ["a", "e"]:
        outword = outword[:-1]
    def tweak(form: str) -> str:
        if outword == word:
            return form
        assert form[0] in ["a", "e", "á", "é"]
        return form[1:]
    for form in singular[key].split():
        forms.append((f"{abbr}-{tweak(form)}", f"{outword}{form}"))
    plural_form = plural[key]
    forms.append((f"{abbr}-{tweak(plural_form)}", f"{outword}{plural_form}"))
    for form in singular[plural_form].split():
        forms.append((f"{abbr}-{tweak(plural_form)}{form}", f"{outword}{plural_form}{form}"))
    return forms
naive_inflector("o.", "óra")
naive_inflector("ó", "óra")
naive_inflector("mp", "másodperc")
a = []
a += naive_inflector("mp", "másodperc")
a
foo = "thingsare"
bar = "things"
len(foo)
len(bar)
foo[6:]
from num2words import num2words
num2words(1234, lang="hu")
with open("nemo_text_processing/text_normalization/sv/data/measure/unit.tsv") as unit, open("nemo_text_processing/text_normalization/sv/data/measure/unit_plural.tsv") as pl:
	plurals = pl.readlines()
	units = unit.readlines()
	plur = [x.split("\t")[0] for x in plurals]
	uni = [x.split("\t")[1] for x in units]
	for u in uni:
		if not u in plur:
			print(u)
with open("nemo_text_processing/text_normalization/sv/data/measure/unit.tsv") as unit, open("nemo_text_processing/text_normalization/sv/data/measure/unit_plural.tsv") as pl:
	plurals = pl.readlines()
	units = unit.readlines()
	uni = [x.split("\t")[1] for x in units]
	plur = [x.split("\t")[0] for x in plurals]
	for u in uni:
		if not u in plur:
			print(u)
from pathlib import Path
for file in Path(".").glob("*.pcm"):
	with open(str(file), "rb") as wf:
		HEADER = b'PCM44   \0\0\0\0\0\0\0S'
for file in Path(".").glob("*.pcm"):
	with open(str(file), "rb") as wf:
		HEADER = b'PCM44   \0\0\0\0\0\0\0S'
		wf.seek(0)
		assert wavfile.read(16) == HEADER
for file in Path(".").glob("*.pcm"):
	with open(str(file), "rb") as wf:
		HEADER = b'PCM44   \0\0\0\0\0\0\0S'
		wf.seek(0)
		assert wf.read(16) == HEADER
from nemo_text_processing.text_normalization.en.graph_utils import NEMO_DIGIT
digit_no_zero = (NEMO_DIGIT - "0")
"1" @ NEMO_DIGIT
("1" @ NEMO_DIGIT).string()
("0" @ NEMO_DIGIT).string()
("0" @ digit_no_zero).string()
("1" @ digit_no_zero).string()
from pynini.lib import pynutil
from nemo_text_processing.text_normalization.hu.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.en.taggers.measure import MeasureFst
from nemo_text_processing.text_normalization.en.taggers.fraction import FractionFst
from nemo_text_processing.text_normalization.en.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.en.taggers.ordinal import OrdinalFst
card = CardinalFst()
ord = OrdinalFst(card)
frac = FractionFst(card)
measure = MeasureFst(card, ord, frac)
from nemo_text_processing.text_normalization.en.taggers.decimal import DecimalFst
dec = DecimalFst(card)
dec = DecimalFst(card, True)
measure = MeasureFst(card, dec, frac)
("2.5 million" @ measure)
("2.5 million" @ measure.fst)
("2.5 million" @ measure.fst).string()
("2.5 kg" @ measure.fst).string()
("2.5 kg/h" @ measure.fst).string()
("2.5 kg/s" @ measure.fst).string()
("2.5 kg/min" @ measure.fst).string()
("2.5 kg/$" @ measure.fst).string()
("2.5 $/sec" @ measure.fst).string()
("2.5 kg/sec" @ measure.fst).string()
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.sv.taggers.decimal import DecimalFst
from num2words import num2words
num2words(34, lang="sv")
from pynini.lib import pynutil
import pynini
eos_space = pynini.union("[EOS]", " ")
bos_space = pynini.union("[BOS]", " ")
ones = pynini.cross("one one", "double one")
test = "one ones one one"
crosser = pynini.cross(ones, bos_space, eos_space, NEMO_SIGMA)
from nemo_text_processing.text_normalization.en.graph_utils import NEMO_SIGMA
crosser = pynini.cross(ones, bos_space, eos_space, NEMO_SIGMA)
crosser = pynini.cdrewrite(ones, bos_space, eos_space, NEMO_SIGMA)
(test @ crosser).string()
("one one one one" @ crosser).string()
from num2words import num2words
num2words(21, lang="sv", ordinal=True)
num2words(22, lang="sv", ordinal=True)
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
card = CardinalFst()
("1" @ card.graph_hundreds_component_at_least_one_non_zero_digit).string()
("2" @ card.graph_hundreds_component_at_least_one_non_zero_digit).string()
("211" @ card.graph_hundreds_component_at_least_one_non_zero_digit).string()
("212" @ card.graph_hundreds_component_at_least_one_non_zero_digit).string()
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
card = CardinalFst()
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
card = CardinalFst()
("212" @ card.graph_hundreds_component_at_least_one_non_zero_digit).string()
("2" @ card.graph_hundreds_component_at_least_one_non_zero_digit).string()
from nemo_text_processing.text_normalization.sv.taggers.cardinal import CardinalFst
card = CardinalFst()
("2" @ card.graph_hundreds_component_at_least_one_non_zero_digit).string()
("12" @ card.graph_hundreds_component_at_least_one_non_zero_digit).string()
("312" @ card.graph_hundreds_component_at_least_one_non_zero_digit).string()
("1" @ card.graph_hundreds_component_at_least_one_non_zero_digit).string()
("0" @ card.graph_hundreds_component_at_least_one_non_zero_digit).string()
("1" @ card.graph_hundreds_component_at_least_one_non_zero_digit_en).string()
no_one = card.graph_hundreds_component_at_least_one_non_zero_digit - "1"
import pynini
no_one = (pynini.project(card.graph_hundreds_component_at_least_one_non_zero_digit, "input") - 1) @ card.graph_hundreds_component_at_least_one_non_zero_digit
no_one = (pynini.project(card.graph_hundreds_component_at_least_one_non_zero_digit, "input") - "1") @ card.graph_hundreds_component_at_least_one_non_zero_digit
("1" @ no_one).string()
("2" @ no_one).string()
("11" @ no_one).string()
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst()
("1" @ card.graph).string()
("11" @ card.graph).string()
("10" @ card.graph).string()
("12" @ card.graph).string()
("22" @ card.graph).string()
("222" @ card.graph).string()
("222222" @ card.graph).string()
("222222222" @ card.graph).string()
("2000000" @ card.graph).string()
("1000000" @ card.graph).string()
("5001230" @ card.graph).string()
exp = "vihttamiljovnnaduhatguoktečuođigolbmalogi"
got = "vihttamiljovnnaduhátguoktečuođigolbmalogi"
exp == got
("1 000 000" @ card.graph).string()
("1234567" @ card.graph).string()
got = "miljovdnaguoktečuođigolbmaloginjealljeduhátvihttačuođiguhttalogičieža"
exp = "miljonguoktečuođigolbmaloginjealljeduhatvihttačuođiguhttalogičieža"
exp = 'guoktemiljovnna'
("2000000" @ card.graph).string()
got = 'guoktemiljovnna'
exp == got
("7654321" @ card.graph).string()
got = 'čiežamiljovnnaguhttačuođivihttaloginjealljeduhátgolbmačuođiguoktelogiokta'
exp = 'čiežamiljovnnaguhttačuođivihttaloginjealljeduhatgolbmačuođiguoktelogiokta'
exp == got
("1000001" @ card.graph).string()
("12" @ card.graph).string()
("19" @ card.graph).string()
from nemo_text_processing.text_normalization.se.utils import get_abs_path, load_labels
mnthtsv = "/home/joregan/NeMo-text-processing/nemo_text_processing/text_normalization/se/data/months/numbers.tsv"
num2m = load_labels(mnthtsv)
("1" @ num2m).string()
num2m = pynini.string_file(mnthtsv)
import pynini
num2m = pynini.string_file(mnthtsv)
("1" @ num2m).string()
mname = pynini.project(num2m, "output")
month_nom_to_gen_map = pynini.string_map([("mánnu", "mánu")])
from nemo_text_processing.text_normalization.en.graph_utils import NEMO_SIGMA
rw = pynini.cdrewrite(month_nom_to_gen_map, "", "[EOS]", NEMO_SIGMA)
n2g = mname @ rw
("ođđajagimánnu" @ n2g).string()
pynini.invert(n2g)
g2n = pynini.invert(n2g)
("ođđajagimánu" @ g2n).string()
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst()
("2023" @ card.graph).string()
("27" @ card.graph).string()
("50" @ card.graph).string()
("234" @ card.graph).string()
("216" @ card.graph).string()
("2" @ card.graph).string()
("2004" @ card.graph).string()
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
ord = OrdinalFst()
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
ord = OrdinalFst()
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
ord = OrdinalFst()
("1" @ ord.hundreds).string()
("111" @ ord.hundreds).string()
("211" @ ord.hundreds).string()
("11" @ ord.hundreds).string()
("13" @ ord.hundreds).string()
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
ord = OrdinalFst()
("211" @ ord.hundreds).string()
("200" @ ord.hundreds).string()
("200" @ ordgraph_hundreds_component_at_least_one_non_zero_digit).string()
("200" @ ord.graph_hundreds_component_at_least_one_non_zero_digit).string()
("211" @ ord.graph_hundreds_component_at_least_one_non_zero_digit).string()
("201" @ ord.graph_hundreds_component_at_least_one_non_zero_digit).string()
("221" @ ord.graph_hundreds_component_at_least_one_non_zero_digit).string()
("21" @ ord.graph_hundreds_component_at_least_one_non_zero_digit).string()
("1" @ ord.graph_hundreds_component_at_least_one_non_zero_digit).string()
("12" @ ord.graph_hundreds_component_at_least_one_non_zero_digit).string()
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
ord = OrdinalFst()
("1000000" @ ord.graph_hundreds_component_at_least_one_non_zero_digit).string()
("1000000" @ ord.graph).string()
("1000001" @ ord.graph).string()
("1000000001" @ ord.graph).string()
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
ord = OrdinalFst()
("1000000001." @ ord.graph).string()
("1000000001" @ ord.graph_bare_ordinals).string()
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
card = CardinalFst()
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst()
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst()
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst()
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
ord = OrdinalFst()
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
date = DateFst(card, ord, True)
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(card, ord, True)
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
date = DateFst(card, ord, True)
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(card, ord, True)
("ođđajagemánu 3. b." @ date.md)
("ođđajagemánu 3. b." @ date.md).string()
("ođđajagemánu 3. b." @ date.mdy).string()
("ođđajagem." @ date.month_abbr).string()
("ođđajagim." @ date.month_abbr).string()
("ođđajagimánnu" @ date.nom2gen).string()
("ođđajagimánnu" @ date.months_nom2gen).string()
("2022" @ date.year).string()
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(card, ord, True)
("ođđajagemánu 3. b." @ date.mdy).string()
("2022" @ date.year).string()
("122" @ date.year).string()
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(card, ord, True)
("122" @ date.year).string()
("2122" @ date.year).string()
("ođđajagemánu 3. b." @ date.mdy).string()
("ođđajagemánu 3 b." @ date.mdy).string()
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(card, ord, True)
("ođđajagemánu 3 b." @ date.mdy).string()
("ođđajagemánu 3. b." @ date.mdy).string()
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(card, ord, True)
("ođđajagemánu 3. b." @ date.mdy).string()
("ođđajagemánu 3. b." @ date.md).string()
("ođđajagem. 3. b." @ date.md).string()
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(card, ord, True)
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
date = DateFst(card, ord, True)
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(card, ord, True)
("ođđajagem. 3. b." @ date.md).string()
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(card, ord, True)
("ođđajagem. 3. b." @ date.md).string()
("ođđajagem. 3. b." @ date.mdy).string()
("ođđajagem. 3. b. 2001" @ date.mdy).string()
("skábmamánu 3. b. 1956" @ date.mdy).string()
("skábm. 3. b. 1956" @ date.mdy).string()
("skábmam. 3. b. 1956" @ date.mdy).string()
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(card, ord, True)
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(card, ord, True)
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst()
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
ord = OrdinalFst()
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
date = DateFst(card, ord, True)
("skábmam. 3. b. 1956" @ date.mdy).string()
("11" @ date.months_num2gen).string()
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(card, ord, True)
("11" @ date.months_num2gen).string()
("skábmam. 3. b. 1956" @ date.mdy).string()
("skábmam. 3. b. 1956" @ date.graph).string()
("skábmam. 3. b. 1956" @ date.fst).string()
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(card, ord, True)
("skábmam. 3. b. 1956" @ date.fst).string()
("skábmamánu 3. b. 1956" @ date.fst).string()
("skábmamánu. 3. b. 1956" @ date.fst).string()
("skábmamánnu. 3. b. 1956" @ date.fst).string()
("1956/12/3" @ date.fst).string()
(3-12 1945" @ date.fst).string()
("3-12 1945" @ date.fst).string()
("skábmamánnu. 3. b. 1956" @ date.fst).string()
("skábmam. 3. b. 1956" @ date.fst).string()
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(card, ord, True)
("skábmam. 3. b. 1956" @ date.fst).string()
("skábmamánu 3. b. 1956" @ date.fst).string()
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(card, ord, True)
("skábmamánu 3. b. 1956" @ date.fst).string()
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(card, ord, True)
("skábmamánu 3. b. 1956" @ date.fst).string()
("skábmam. 3. b. 1956" @ date.fst).string()
("1956" @ date.fst).string()
("1956-12" @ date.fst).string()
("1/2/1956" @ date.fst).string()
("01/12/1956" @ date.fst).string()
("11/12/1956" @ date.fst).string()
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(card, ord, True)
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(card, ord, True)
("11/12/1956" @ date.fst).string()
("11/12" @ date.fst).string()
("11-12" @ date.fst).string()
("1956-12" @ date.fst).string()
("1956-12-13" @ date.fst).string()
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(card, ord, True)
("1956-12-13" @ date.ymd).string()
("11-12" @ date.dmy).string()
("1956-12-" @ date.ymd).string()
("1956-12" @ date.ymd).string()
from pynini.lib import pynutil
import pynini
from nemo_text_processing.text_normalization.en.graph_utils import NEMO_DIGIT
delete_leading_zero = (pynutil.delete("0") | (NEMO_DIGIT - "0")) + NEMO_DIGIT
optional_leading_zero = delete_leading_zero | NEMO_DIGIT
month_number = (pynutil.insert("month: \"") + (pynutil.add_weight(digit_month, weight=0.0001) | number_to_month) + pynutil.insert("\""))
digit_month = optional_leading_zero @ pynini.union(*[str(x) for x in range(1, 13)])
number_to_month = digit_month @ date.months_num2gen
("12" @ digit_month).string()
("12" @ number_to_month).string()
from nemo_text_processing.text_normalization.en.graph_utils import NEMO_DIGIT
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
("1956-12" @ date.ymd).string()
("1956-12-12" @ date.ymd).string()
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
("1956-12-12" @ date.ymd).string()
("1956-12" @ date.ymd).string()
("11-12" @ date.dmy).string()
("11-12 1925" @ date.dmy).string()
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
("11-12 1925" @ date.dmy).string()
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
("11-12 1925" @ date.dmy).string()
("11/12/1925" @ date.dmy).string()
("2/1/1925" @ date.dmy).string()
("2/1" @ date.dmy).string()
("2/1/22" @ date.dmy).string()
("2/1/222" @ date.dmy).string()
("2-12" @ date.dmy).string()
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
from nemo_text_processing.text_normalization.se.taggers.date import DateFst
card = CardinalFst()
ord = OrdinalFst()
date = DateFst(cardinal=card, ordinal=ord, deterministic=True)
("2/1/222" @ date.dmy).string()
("2-1 222" @ date.dmy).string()
("2-1 222" @ date.fst).string()
("2022-12-12" @ date.fst).string()
("2022/12/12" @ date.fst).string()
from nemo_text_processing.text_normalization.se.taggers.cardinal import CardinalFst
card = CardinalFst()
("20000000" @ card.fst).string()
from nemo_text_processing.text_normalization.se.taggers.ordinal import OrdinalFst
ord = OrdinalFst()
ord = OrdinalFst(card)
from num2words import num2words
num2words(114, lang="sv")
num2words(113, lang="sv")
num2words(11, lang="sv")
num2words(77, lang="sv")
num2words(900, lang="sv")
_SWE_MODEL = "KBLab/wav2vec2-large-voxrex-swedish"
from transformers import pipeline
pipe = pipeline(model=_SWE_MODEL)
help(pipeline)
pipe = pipeline(model=_SWE_MODEL, device=1)
file = 'BvxsYEPIqUs.mp4'
output = pipe(file,  chunk_length_s=10, return_timestamps="word")
import glob
import whisper_timestamped
import whisper_timestamped as whisper
for wav in glob.glob("*wav"):
	audio = whisper.load_audio(wav)
	model = whisper.load_model("large", device=1)
	res = whisper.transcribe(model, audio, language="sv")
	import json
	with open(wav.replace('.wav', '.w.json'), 'w') as of:
		json.dump(res, of)
model = whisper.load_model("large", device="1")
model = whisper.load_model("large", device="cuda")
for wav in glob.glob("*wav"):
	audio = whisper.load_audio(wav)
	res = whisper.transcribe(model, audio, language="sv")
	with open(wav.replace('.wav', '.w.json'), 'w') as of:
		json.dump(res, of)
import json
for wav in glob.glob("*wav"):
	audio = whisper.load_audio(wav)
res
wav
with open(wav.replace('.wav', '.w.json'), 'w') as of:
	json.dump(res, of)
for wav in glob.glob("*wav"):
	audio = whisper.load_audio(wav)
	res = whisper.transcribe(model, audio, language="sv")
	with open(wav.replace('.wav', '.w.json'), 'w') as of:
		json.dump(res, of)
